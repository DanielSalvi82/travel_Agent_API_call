name: Fireworks proxy (minimal status webhook)

permissions:
  contents: write

on:
  workflow_dispatch:
    inputs:
      prompt:
        description: 'Prompt para o Kimi K2 (string ou JSON compact)'
        required: true
        type: string
      request_id:
        description: 'ID único da requisição'
        required: true
        type: string
      webhook_url:
        description: 'Optional Make webhook URL to notify'
        required: false
        type: string
      needs_polling:
        description: 'true or false'
        required: false
        default: 'true'
  repository_dispatch:
    types: [fireworks-request-sync, fireworks-callback]

jobs:
  process-api:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Read client_payload (extract fields)
        id: read
        run: |
          set -euo pipefail

          PROMPT_RAW=$(jq -c -r '.client_payload.prompt // .inputs.prompt // empty' "$GITHUB_EVENT_PATH" 2>/dev/null || true)
          REQUEST_ID=$(jq -r '.client_payload.request_id // .inputs.request_id // empty' "$GITHUB_EVENT_PATH" 2>/dev/null || true)
          WEBHOOK_URL=$(jq -r '.client_payload.webhook_url // .inputs.webhook_url // empty' "$GITHUB_EVENT_PATH" 2>/dev/null || true)
          NEEDS_POLLING=$(jq -r '.client_payload.needs_polling // .inputs.needs_polling // "true"' "$GITHUB_EVENT_PATH" 2>/dev/null || true)

          INPUT_MESSAGE=$(jq -c -r '.client_payload.input_message // .client_payload.InputMessage // .inputs.input_message // empty' "$GITHUB_EVENT_PATH" 2>/dev/null || true)
          CHAT_HISTORY=$(jq -c -r '.client_payload.chathistory // .client_payload.ChatHistory // .inputs.chathistory // empty' "$GITHUB_EVENT_PATH" 2>/dev/null || true)
          TRAVELER_PROFILE=$(jq -c -r '.client_payload.traveler_profile // .client_payload.TravelerProfile // .inputs.traveler_profile // empty' "$GITHUB_EVENT_PATH" 2>/dev/null || true)
          TRAVEL_INPUTS=$(jq -c -r '.client_payload.travel_inputs // .client_payload.TravelInputs // .inputs.travel_inputs // empty' "$GITHUB_EVENT_PATH" 2>/dev/null || true)
          USER_ID_INPUT=$(jq -r '.client_payload.user_id // .client_payload.userID // .inputs.user_id // empty' "$GITHUB_EVENT_PATH" 2>/dev/null || true)

          echo "prompt_raw<<EOF" >> $GITHUB_OUTPUT
          echo "$PROMPT_RAW" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "request_id=$REQUEST_ID" >> $GITHUB_OUTPUT
          echo "webhook_url=$WEBHOOK_URL" >> $GITHUB_OUTPUT
          echo "needs_polling=$NEEDS_POLLING" >> $GITHUB_OUTPUT

          echo "input_message<<EOF" >> $GITHUB_OUTPUT
          echo "$INPUT_MESSAGE" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "chathistory<<EOF" >> $GITHUB_OUTPUT
          echo "$CHAT_HISTORY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "traveler_profile<<EOF" >> $GITHUB_OUTPUT
          echo "$TRAVELER_PROFILE" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "travel_inputs<<EOF" >> $GITHUB_OUTPUT
          echo "$TRAVEL_INPUTS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "user_id_input=$USER_ID_INPUT" >> $GITHUB_OUTPUT

      - name: Call Fireworks model (ordered payload, robust extraction)
        id: call_fireworks
        env:
          FIREWORKS_API_KEY: ${{ secrets.FIREWORKS_API_KEY }}
          PROMPT_RAW: ${{ steps.read.outputs.prompt_raw }}
          REQUEST_ID: ${{ steps.read.outputs.request_id }}
          NEEDS_POLLING: ${{ steps.read.outputs.needs_polling }}
          INPUT_MESSAGE_RAW: ${{ steps.read.outputs.input_message }}
          CHAT_HISTORY_RAW: ${{ steps.read.outputs.chathistory }}
          TRAVELER_PROFILE_RAW: ${{ steps.read.outputs.traveler_profile }}
          TRAVEL_INPUTS_RAW: ${{ steps.read.outputs.travel_inputs }}
          USER_ID_VAR: ${{ steps.read.outputs.user_id_input }}
        run: |
          set -euo pipefail

          # helper: convert raw to JSON or JSON-string
          to_json_or_null() {
            local raw="$1"
            if [ -z "$raw" ]; then
              printf 'null'
            else
              if printf '%s' "$raw" | jq -e . >/dev/null 2>&1; then
                printf '%s' "$raw"
              else
                printf '%s' "$(jq -Rn --arg s "$raw" '$s')"
              fi
            fi
          }

          INPUT_MESSAGE_JSON=$(to_json_or_null "$INPUT_MESSAGE_RAW")
          PROMPT_JSON=$(to_json_or_null "$PROMPT_RAW")
          CHATHISTORY_JSON=$(to_json_or_null "$CHAT_HISTORY_RAW")
          TRAVELER_PROFILE_JSON=$(to_json_or_null "$TRAVELER_PROFILE_RAW")
          TRAVEL_INPUTS_JSON=$(to_json_or_null "$TRAVEL_INPUTS_RAW")

          # Build ordered payload for scenario 1
          PAYLOAD_SCENARIO1=$(jq -n \
            --argjson input_message "$INPUT_MESSAGE_JSON" \
            --argjson prompt "$PROMPT_JSON" \
            --argjson chathistory "$CHATHISTORY_JSON" \
            --argjson traveler_profile "$TRAVELER_PROFILE_JSON" \
            --argjson travel_inputs "$TRAVEL_INPUTS_JSON" \
            '{
              input_message: $input_message,
              prompt: $prompt,
              chathistory: $chathistory,
              traveler_profile: $traveler_profile,
              travel_inputs: $travel_inputs
            }'
          )

          echo "PAYLOAD_SCENARIO1:"
          echo "$PAYLOAD_SCENARIO1" | jq .

          # Prepare request body (input contains ordered payload)
          if [[ "${NEEDS_POLLING}" == "true" ]]; then
            REQUEST_BODY=$(jq -n --argjson ordered_input "$PAYLOAD_SCENARIO1" '{
              model: "accounts/fireworks/models/kimi-k2-thinking",
              max_tokens: 16000,
              temperature: 0.5,
              input: $ordered_input,
              stream: true
            }')
          else
            REQUEST_BODY=$(jq -n --argjson ordered_input "$PAYLOAD_SCENARIO1" '{
              model: "accounts/fireworks/models/kimi-k2-thinking",
              max_tokens: 16000,
              temperature: 0.5,
              input: $ordered_input,
              stream: false
            }')
          fi

          echo "Calling Fireworks (stream=${NEEDS_POLLING})..."

          RESPONSE_RAW=""
          RESPONSE_TEXT=""

          if [[ "${NEEDS_POLLING}" == "true" ]]; then
            # streaming: accumulate pieces into RESPONSE_RAW
            while IFS= read -r line; do
              if [[ $line == data:* ]]; then
                JSON_DATA="${line#data:}"
                JSON_TRIM=$(printf '%s' "$JSON_DATA" | tr -d '\r\n')
                if [[ "$JSON_TRIM" == "[DONE]" ]]; then
                  break
                fi
                if [[ -n "$JSON_TRIM" ]]; then
                  RESPONSE_RAW+="$JSON_TRIM"$'\n'
                fi
              fi
            done < <(
              curl -s -N https://api.fireworks.ai/inference/v1/chat/completions \
                -H "Authorization: Bearer $FIREWORKS_API_KEY" \
                -H "Content-Type: application/json" \
                -d "$REQUEST_BODY"
            )

            # Try to extract best text from accumulated streaming JSON lines
            # Strategy: look for delta.content fragments, then join; fallback to any message fields
            RESPONSE_TEXT=$(printf '%s' "$RESPONSE_RAW" | jq -r -s '
              map(select(. != "" ) | fromjson? ) |
              (map(.choices? // [] | .[] | .delta? // {} | .content? // empty) | join("")) as $delta |
              ($delta // "") as $d |
              (if $d != "" then $d
               else (map(.choices? // [] | .[] | .message? // {} | .content? // empty) | join("\n")) end)
            ' 2>/dev/null || true)

            # final fallback: raw text
            if [ -z "$RESPONSE_TEXT" ]; then
              RESPONSE_TEXT=$(printf '%s' "$RESPONSE_RAW" | tr -d '\r\n')
            fi

          else
            # synchronous call
            SYNC_RAW=$(curl -s -X POST https://api.fireworks.ai/inference/v1/chat/completions \
              -H "Authorization: Bearer $FIREWORKS_API_KEY" \
              -H "Content-Type: application/json" \
              -d "$REQUEST_BODY" || true)

            echo "Fireworks sync raw:"
            echo "$SYNC_RAW" | jq . || echo "$SYNC_RAW"

            # Extraction strategies (ordered preference)
            RESPONSE_TEXT=$(printf '%s' "$SYNC_RAW" | jq -r '
              .response_text_clean // .response_text_markdown // .response.text // .response_text // .choices[0].message.content // .choices[0].message // .choices[0].text // empty
            ' 2>/dev/null || true)

            if [ -z "$RESPONSE_TEXT" ]; then
              # Try alternative nested fields or fallback to raw
              RESPONSE_TEXT=$(printf '%s' "$SYNC_RAW" | jq -r '
                (.. | objects | .response_text? // .response? // .text? // empty) | select(. != null) | tostring
              ' 2>/dev/null | head -n 1 || true)
            fi

            if [ -z "$RESPONSE_TEXT" ]; then
              RESPONSE_TEXT="$SYNC_RAW"
            fi
          fi

          # Trim whitespace
          RESPONSE_TEXT=$(printf '%s' "$RESPONSE_TEXT" | sed -e 's/^[[:space:]\n\r]*//' -e 's/[[:space:]\n\r]*$//')

          # Export outputs
          echo "message_extracted<<EOF" >> $GITHUB_OUTPUT
          echo "$RESPONSE_TEXT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "payload_scenario1<<EOF" >> $GITHUB_OUTPUT
          echo "$PAYLOAD_SCENARIO1" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Create minimal status and notify webhook (only request_id,status,response,user_id)
        env:
          REQUEST_ID: ${{ steps.read.outputs.request_id }}
          NEEDS_POLLING: ${{ steps.read.outputs.needs_polling }}
          WEBHOOK_URL: ${{ steps.read.outputs.webhook_url }}
          WEBHOOK_SECRET: ${{ secrets.WEBHOOK_SECRET }}
          MESSAGE_EXTRACTED: ${{ steps.call_fireworks.outputs.message_extracted }}
          USER_ID_VAR: ${{ steps.read.outputs.user_id_input }}
        run: |
          set -euo pipefail

          # Ensure we have a response text (fallback to empty string)
          RESPONSE_TEXT="${MESSAGE_EXTRACTED:-}"
          if [ -z "$RESPONSE_TEXT" ]; then
            RESPONSE_TEXT=""
          fi

          # Build minimal status JSON with only required fields
          MINIMAL_STATUS=$(jq -n \
            --arg rid "$REQUEST_ID" \
            --arg status "completed" \
            --arg response_text "$RESPONSE_TEXT" \
            --arg user_id "$USER_ID_VAR" \
            '{
              request_id: $rid,
              status: $status,
              response: { text: $response_text },
              user_id: $user_id
            }'
          )

          echo "MINIMAL_STATUS:"
          echo "$MINIMAL_STATUS" | jq .

          if [[ "${NEEDS_POLLING}" == "true" ]]; then
            # write minimal status file
            mkdir -p status
            echo "$MINIMAL_STATUS" > status/$REQUEST_ID.json

            git config user.name "github-actions[bot]"
            git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
            git add status/$REQUEST_ID.json
            git commit -m "Write minimal status for $REQUEST_ID" || echo "no changes to commit"
            git push || echo "git push failed (continuing)"

            # Notify external webhook with minimal payload
            if [ -n "${WEBHOOK_URL:-}" ]; then
              PAYLOAD_NOTIFY="$MINIMAL_STATUS"
              EXTRA_HEADERS=()
              if [ -n "${WEBHOOK_SECRET:-}" ]; then
                SIG='sha256='$(printf '%s' "$PAYLOAD_NOTIFY" | openssl dgst -sha256 -hmac "$WEBHOOK_SECRET" -binary | xxd -p -c 256)
                EXTRA_HEADERS+=("-H" "X-Hub-Signature-256: $SIG")
              fi

              MAX_RETRIES=3
              ATTEMPT=1
              SUCCESS=0
              while [ $ATTEMPT -le $MAX_RETRIES ]; do
                HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" -X POST "$WEBHOOK_URL" \
                  -H "Content-Type: application/json" \
                  "${EXTRA_HEADERS[@]}" \
                  --data-binary "$PAYLOAD_NOTIFY" || echo "000")
                if [ "$HTTP_STATUS" = "200" ] || [ "$HTTP_STATUS" = "201" ] || [ "$HTTP_STATUS" = "204" ]; then
                  SUCCESS=1
                  break
                else
                  sleep $((2 ** ATTEMPT))
                  ATTEMPT=$((ATTEMPT + 1))
                fi
              done

              if [ $SUCCESS -ne 1 ]; then
                echo "Webhook notify attempts failed; last status $HTTP_STATUS"
              fi
            else
              echo "No WEBHOOK_URL provided; skipping notify."
            fi
          else
            echo "NEEDS_POLLING != true -> skipping status file creation and webhook notify (scenario 1)."
          fi

      - name: Post job cleanup
        if: always()
        run: |
          echo "Done processing request_id=${{ steps.read.outputs.request_id }}"
