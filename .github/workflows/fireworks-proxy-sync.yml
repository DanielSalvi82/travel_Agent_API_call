name: Fireworks AI Proxy (streaming, ordered payload, minimal webhook)

on:
  repository_dispatch:
    types: [fireworks-request-sync]
  workflow_dispatch:
    inputs:
      prompt:
        description: 'Prompt para o Kimi K2'
        required: true
        type: string
      request_id:
        description: 'ID único da requisição'
        required: true
        type: string
      webhook_url:
        description: 'URL do webhook Make.com'
        required: true
        type: string
      needs_polling:
        description: 'true or false (se deve criar status file e notificar)'
        required: false
        default: 'true'

permissions:
  contents: write

jobs:
  process-api:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Process Fireworks AI Streaming (ordered payload, reasoning, minimal webhook)
        env:
          FIREWORKS_API_KEY: ${{ secrets.FIREWORKS_API_KEY }}
          PROMPT: ${{ github.event.inputs.prompt || github.event.client_payload.prompt }}
          REQUEST_ID: ${{ github.event.inputs.request_id || github.event.client_payload.request_id }}
          WEBHOOK_URL: ${{ github.event.inputs.webhook_url || github.event.client_payload.webhook_url }}
          NEEDS_POLLING: ${{ github.event.inputs.needs_polling || github.event.client_payload.needs_polling || 'true' }}
        run: |
          set -euo pipefail

          # Accumulators
          ANALYSIS=""
          RESPONSE=""
          ERROR_MSG=""

          # Try to extract structured scenario inputs from client_payload if present (preserve order)
          # If not present, fall back to using PROMPT as messages content
          # We build an "input" object with the exact order required:
          # input_message, prompt, chathistory, traveler_profile, travel_inputs

          # Helper: read raw client_payload fields if available (safe jq from env)
          # Note: github.event.client_payload may not be available in workflow_dispatch; we rely on PROMPT and other inputs.
          CLIENT_PAYLOAD_PATH="${GITHUB_EVENT_PATH:-}"

          # Attempt to read specific fields from event payload (if present)
          INPUT_MESSAGE_RAW=""
          PROMPT_RAW=""
          CHATHISTORY_RAW=""
          TRAVELER_PROFILE_RAW=""
          TRAVEL_INPUTS_RAW=""
          USER_ID_RAW=""

          if [ -n "${CLIENT_PAYLOAD_PATH:-}" ] && [ -f "$CLIENT_PAYLOAD_PATH" ]; then
            INPUT_MESSAGE_RAW=$(jq -c -r '.client_payload.input_message // .client_payload.InputMessage // empty' "$CLIENT_PAYLOAD_PATH" 2>/dev/null || true)
            PROMPT_RAW=$(jq -c -r '.client_payload.prompt // .inputs.prompt // empty' "$CLIENT_PAYLOAD_PATH" 2>/dev/null || true)
            CHATHISTORY_RAW=$(jq -c -r '.client_payload.chathistory // .client_payload.ChatHistory // empty' "$CLIENT_PAYLOAD_PATH" 2>/dev/null || true)
            TRAVELER_PROFILE_RAW=$(jq -c -r '.client_payload.traveler_profile // .client_payload.TravelerProfile // empty' "$CLIENT_PAYLOAD_PATH" 2>/dev/null || true)
            TRAVEL_INPUTS_RAW=$(jq -c -r '.client_payload.travel_inputs // .client_payload.TravelInputs // empty' "$CLIENT_PAYLOAD_PATH" 2>/dev/null || true)
            USER_ID_RAW=$(jq -r '.client_payload.user_id // .client_payload.userID // empty' "$CLIENT_PAYLOAD_PATH" 2>/dev/null || true)
          fi

          # If PROMPT env is set and PROMPT_RAW empty, use PROMPT
          if [ -z "$PROMPT_RAW" ] && [ -n "${PROMPT:-}" ]; then
            PROMPT_RAW="$PROMPT"
          fi

          # Helper to convert raw to JSON or JSON-string for jq --argjson usage
          to_json_or_null() {
            local raw="$1"
            if [ -z "$raw" ]; then
              printf 'null'
            else
              # If already valid JSON, return as-is; else return JSON string
              if printf '%s' "$raw" | jq -e . >/dev/null 2>&1; then
                printf '%s' "$raw"
              else
                printf '%s' "$(jq -Rn --arg s "$raw" '$s')"
              fi
            fi
          }

          INPUT_MESSAGE_JSON=$(to_json_or_null "$INPUT_MESSAGE_RAW")
          PROMPT_JSON=$(to_json_or_null "$PROMPT_RAW")
          CHATHISTORY_JSON=$(to_json_or_null "$CHATHISTORY_RAW")
          TRAVELER_PROFILE_JSON=$(to_json_or_null "$TRAVELER_PROFILE_RAW")
          TRAVEL_INPUTS_JSON=$(to_json_or_null "$TRAVEL_INPUTS_RAW")

          # Build ordered payload for Fireworks under "input" field (order preserved by jq)
          PAYLOAD_SCENARIO1=$(jq -n \
            --argjson input_message "$INPUT_MESSAGE_JSON" \
            --argjson prompt "$PROMPT_JSON" \
            --argjson chathistory "$CHATHISTORY_JSON" \
            --argjson traveler_profile "$TRAVELER_PROFILE_JSON" \
            --argjson travel_inputs "$TRAVEL_INPUTS_JSON" \
            '{
              input_message: $input_message,
              prompt: $prompt,
              chathistory: $chathistory,
              traveler_profile: $traveler_profile,
              travel_inputs: $travel_inputs
            }'
          )

          echo "=== PAYLOAD_SCENARIO1 (ordered) ==="
          echo "$PAYLOAD_SCENARIO1" | jq .

          # Build request body for streaming (keep stream: true)
          REQUEST_BODY=$(jq -n --argjson ordered_input "$PAYLOAD_SCENARIO1" '{
            model: "accounts/fireworks/models/kimi-k2-thinking",
            max_tokens: 16000,
            temperature: 0.5,
            input: $ordered_input,
            stream: true
          }')

          echo "Calling Fireworks (stream=true) with ordered input..."

          # Initialize streaming accumulators and counters
          RESPONSE_RAW=""
          REASONING_RAW=""
          DELTA_COUNT=0
          REASONING_COUNT=0
          CURL_ERR_FILE=$(mktemp)

          # Use curl --no-buffer to reduce buffering; accept both SSE and JSON chunked
          (
            curl --no-buffer -s -N https://api.fireworks.ai/inference/v1/chat/completions \
              -H "Authorization: Bearer $FIREWORKS_API_KEY" \
              -H "Content-Type: application/json" \
              -H "Accept: text/event-stream, application/json" \
              -d "$REQUEST_BODY"
          ) 2>"$CURL_ERR_FILE" | while IFS= read -r line; do
            # handle SSE "data:" lines and raw JSON lines
            if [[ $line == data:* ]]; then
              JSON_DATA="${line#data:}"
            else
              JSON_DATA="$line"
            fi

            JSON_TRIM=$(printf '%s' "$JSON_DATA" | tr -d '\r\n')
            if [[ -z "$JSON_TRIM" ]]; then
              continue
            fi
            if [[ "$JSON_TRIM" == "[DONE]" ]]; then
              echo "STREAM: received [DONE]"
              continue
            fi

            # Append raw for debug
            RESPONSE_RAW+="$JSON_TRIM"$'\n'

            # Try to extract reasoning fragment (delta.reasoning_content)
            FRAG_REASONING=$(printf '%s' "$JSON_TRIM" | jq -r '.choices? // [] | .[] | .delta? // {} | .reasoning_content? // empty' 2>/dev/null || true)
            if [[ -n "$FRAG_REASONING" ]]; then
              REASONING_RAW+="$FRAG_REASONING"
              REASONING_COUNT=$((REASONING_COUNT+1))
            fi

            # Try to extract content fragment (delta.content)
            FRAG_CONTENT=$(printf '%s' "$JSON_TRIM" | jq -r '.choices? // [] | .[] | .delta? // {} | .content? // empty' 2>/dev/null || true)
            if [[ -n "$FRAG_CONTENT" ]]; then
              # preserve newlines between chunks
              if [[ -n "$RESPONSE" ]]; then
                RESPONSE+=$'\n'"$FRAG_CONTENT"
              else
                RESPONSE="$FRAG_CONTENT"
              fi
              DELTA_COUNT=$((DELTA_COUNT+1))
            fi

            # Also try to capture full message fields if present (non-delta)
            FULL_MSG=$(printf '%s' "$JSON_TRIM" | jq -r '.choices? // [] | .[] | .message? // empty' 2>/dev/null || true)
            if [[ -n "$FULL_MSG" && "$FULL_MSG" != "null" ]]; then
              MSG_CONTENT=$(printf '%s' "$FULL_MSG" | jq -r '.content // empty' 2>/dev/null || true)
              if [[ -n "$MSG_CONTENT" ]]; then
                if [[ -n "$RESPONSE" ]]; then
                  RESPONSE+=$'\n'"$MSG_CONTENT"
                else
                  RESPONSE="$MSG_CONTENT"
                fi
              else
                # append raw message object as fallback
                if [[ -n "$RESPONSE" ]]; then
                  RESPONSE+=$'\n'"$FULL_MSG"
                else
                  RESPONSE="$FULL_MSG"
                fi
              fi
            fi

            # Capture error if present
            PART_ERROR=$(printf '%s' "$JSON_TRIM" | jq -r '.error.message // empty' 2>/dev/null || true)
            if [[ -n "$PART_ERROR" ]]; then
              if [[ -n "$ERROR_MSG" ]]; then
                ERROR_MSG+=$'\n'"$PART_ERROR"
              else
                ERROR_MSG="$PART_ERROR"
              fi
            fi
          done

          CURL_EXIT=$? || true
          if [ -s "$CURL_ERR_FILE" ]; then
            echo "CURL STDERR (preview):"
            head -c 2000 "$CURL_ERR_FILE" || true
          fi
          rm -f "$CURL_ERR_FILE" || true

          echo "STREAM DEBUG: delta fragments collected: $DELTA_COUNT"
          echo "STREAM DEBUG: reasoning fragments collected: $REASONING_COUNT"
          echo "STREAM DEBUG: first 2000 chars of RESPONSE_RAW:"
          printf '%s' "$RESPONSE_RAW" | head -c 2000 || true
          echo
          echo "STREAM DEBUG: first 2000 chars of REASONING_RAW:"
          printf '%s' "$REASONING_RAW" | head -c 2000 || true
          echo

          # Trim leading/trailing whitespace/newlines
          RESPONSE="$(printf '%s' "$RESPONSE" | sed -e 's/^[[:space:]\n\r]*//' -e 's/[[:space:]\n\r]*$//')"
          ANALYSIS="$(printf '%s' "$ANALYSIS" | sed -e 's/^[[:space:]\n\r]*//' -e 's/[[:space:]\n\r]*$//')"
          ERROR_MSG="$(printf '%s' "$ERROR_MSG" | sed -e 's/^[[:space:]\n\r]*//' -e 's/[[:space:]\n\r]*$//')"

          # If we collected reasoning fragments in REASONING_RAW, use them; else try to extract from RESPONSE_RAW
          if [ -n "$REASONING_RAW" ]; then
            REASONING_TEXT="$(printf '%s' "$REASONING_RAW" | sed -e 's/^[[:space:]\n\r]*//' -e 's/[[:space:]\n\r]*$//')"
          else
            # attempt to extract reasoning from accumulated JSON lines
            REASONING_TEXT=$(printf '%s' "$RESPONSE_RAW" | jq -r -s '
              map(select(. != "" ) | fromjson? ) |
              (map(.choices? // [] | .[] | .delta? // {} | .reasoning_content? // empty) | join("")) as $r |
              ($r // "") as $res |
              $res
            ' 2>/dev/null || true)
            REASONING_TEXT="$(printf '%s' "$REASONING_TEXT" | sed -e 's/^[[:space:]\n\r]*//' -e 's/[[:space:]\n\r]*$//')"
          fi

          # Final fallback: if RESPONSE empty, try to extract from RESPONSE_RAW JSON lines
          if [ -z "$RESPONSE" ]; then
            RESPONSE=$(printf '%s' "$RESPONSE_RAW" | jq -r -s '
              map(select(. != "" ) | fromjson? ) |
              (map(.choices? // [] | .[] | .delta? // {} | .content? // empty) | join("")) as $delta |
              ($delta // "") as $d |
              (if $d != "" then $d
               else (map(.choices? // [] | .[] | .message? // {} | .content? // empty) | join("\n")) end)
            ' 2>/dev/null || true)
            RESPONSE="$(printf '%s' "$RESPONSE" | sed -e 's/^[[:space:]\n\r]*//' -e 's/[[:space:]\n\r]*$//')"
          fi

          # If still empty, set explicit fallback marker so webhook consumers see a clear signal
          if [ -z "${RESPONSE// }" ]; then
            RESPONSE="__NO_RESPONSE_FROM_MODEL__"
            echo "WARN: response empty after parsing -> using fallback marker"
          fi

          # Build minimal payload for webhook: request_id, status, response.text, user_id, reasoning
          MINIMAL_STATUS=$(jq -n \
            --arg rid "$REQUEST_ID" \
            --arg status "completed" \
            --arg response_text "$RESPONSE" \
            --arg user_id "${USER_ID_RAW:-}" \
            --arg reasoning_text "${REASONING_TEXT:-}" \
            '{
              request_id: $rid,
              status: $status,
              response: { text: $response_text },
              user_id: $user_id,
              reasoning: $reasoning_text
            }'
          )

          echo "Payload to send to webhook (minimal):"
          echo "$MINIMAL_STATUS" | jq .

          # If NEEDS_POLLING true, write status file and notify webhook
          if [[ "${NEEDS_POLLING}" == "true" ]]; then
            mkdir -p status
            echo "$MINIMAL_STATUS" > status/$REQUEST_ID.json

            git config user.name "github-actions[bot]"
            git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
            git add status/$REQUEST_ID.json
            git commit -m "Write minimal status for $REQUEST_ID" || echo "no changes to commit"
            git push || echo "git push failed (continuing)"

            if [ -n "${WEBHOOK_URL:-}" ]; then
              PAYLOAD_NOTIFY="$MINIMAL_STATUS"
              MAX_RETRIES=3
              ATTEMPT=1
              SUCCESS=0
              while [ $ATTEMPT -le $MAX_RETRIES ]; do
                HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" -X POST "$WEBHOOK_URL" \
                  -H "Content-Type: application/json" \
                  --data-binary "$PAYLOAD_NOTIFY" || echo "000")
                echo "Webhook notify attempt $ATTEMPT -> HTTP $HTTP_STATUS"
                if [ "$HTTP_STATUS" = "200" ] || [ "$HTTP_STATUS" = "201" ] || [ "$HTTP_STATUS" = "204" ]; then
                  SUCCESS=1
                  break
                else
                  sleep $((2 ** ATTEMPT))
                  ATTEMPT=$((ATTEMPT + 1))
                fi
              done

              if [ $SUCCESS -ne 1 ]; then
                echo "Webhook notify attempts failed; last status $HTTP_STATUS"
              fi
            else
              echo "No WEBHOOK_URL provided; skipping notify."
            fi
          else
            echo "NEEDS_POLLING != true -> skipping status file creation and webhook notify."
          fi

          echo "Done processing request_id=$REQUEST_ID"
