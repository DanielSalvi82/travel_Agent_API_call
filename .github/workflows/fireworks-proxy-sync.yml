name: Fireworks proxy sync (streaming + minimal Make callback)

permissions:
  contents: write

on:
  workflow_dispatch:
    inputs:
      prompt:
        description: 'Prompt para o Kimi K2 (string ou JSON compact)'
        required: true
        type: string
      request_id:
        description: 'ID único da requisição'
        required: true
        type: string
      webhook_url:
        description: 'Optional Make webhook URL to notify'
        required: false
        type: string
      needs_polling:
        description: 'true or false'
        required: false
        default: 'true'
  repository_dispatch:
    types: [fireworks-request-sync, fireworks-callback]

jobs:
  process-api:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Read client_payload (extract all fields)
        id: read
        run: |
          # Extract compact JSON/string fields from event payload (works for workflow_dispatch and repository_dispatch)
          PROMPT_RAW=$(jq -c -r '.client_payload.prompt // .inputs.prompt // empty' "$GITHUB_EVENT_PATH" 2>/dev/null || true)
          REQUEST_ID=$(jq -r '.client_payload.request_id // .inputs.request_id // empty' "$GITHUB_EVENT_PATH" 2>/dev/null || true)
          WEBHOOK_URL=$(jq -r '.client_payload.webhook_url // .inputs.webhook_url // empty' "$GITHUB_EVENT_PATH" 2>/dev/null || true)
          NEEDS_POLLING=$(jq -r '.client_payload.needs_polling // .inputs.needs_polling // "true"' "$GITHUB_EVENT_PATH" 2>/dev/null || true)

          INPUT_MESSAGE=$(jq -c -r '.client_payload.input_message // .client_payload.InputMessage // .inputs.input_message // empty' "$GITHUB_EVENT_PATH" 2>/dev/null || true)
          CHAT_HISTORY=$(jq -c -r '.client_payload.chathistory // .client_payload.ChatHistory // .inputs.chathistory // empty' "$GITHUB_EVENT_PATH" 2>/dev/null || true)
          TRAVELER_PROFILE=$(jq -c -r '.client_payload.traveler_profile // .client_payload.TravelerProfile // .inputs.traveler_profile // empty' "$GITHUB_EVENT_PATH" 2>/dev/null || true)
          TRAVEL_INPUTS=$(jq -c -r '.client_payload.travel_inputs // .client_payload.TravelInputs // .inputs.travel_inputs // empty' "$GITHUB_EVENT_PATH" 2>/dev/null || true)
          USER_ID_INPUT=$(jq -r '.client_payload.user_id // .client_payload.userID // .inputs.user_id // empty' "$GITHUB_EVENT_PATH" 2>/dev/null || true)

          echo "prompt_raw<<EOF" >> $GITHUB_OUTPUT
          echo "$PROMPT_RAW" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "request_id=$REQUEST_ID" >> $GITHUB_OUTPUT
          echo "webhook_url=$WEBHOOK_URL" >> $GITHUB_OUTPUT
          echo "needs_polling=$NEEDS_POLLING" >> $GITHUB_OUTPUT

          echo "input_message<<EOF" >> $GITHUB_OUTPUT
          echo "$INPUT_MESSAGE" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "chathistory<<EOF" >> $GITHUB_OUTPUT
          echo "$CHAT_HISTORY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "traveler_profile<<EOF" >> $GITHUB_OUTPUT
          echo "$TRAVELER_PROFILE" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "travel_inputs<<EOF" >> $GITHUB_OUTPUT
          echo "$TRAVEL_INPUTS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          # Use a non-reserved name for the user id output to avoid shell readonly conflicts
          echo "user_id_input=$USER_ID_INPUT" >> $GITHUB_OUTPUT

      - name: Process Fireworks AI Streaming and persist results
        env:
          FIREWORKS_API_KEY: ${{ secrets.FIREWORKS_API_KEY }}
          PROMPT_RAW: ${{ steps.read.outputs.prompt_raw }}
          REQUEST_ID: ${{ steps.read.outputs.request_id }}
          WEBHOOK_URL: ${{ steps.read.outputs.webhook_url }}
          NEEDS_POLLING: ${{ steps.read.outputs.needs_polling }}
          INPUT_MESSAGE_RAW: ${{ steps.read.outputs.input_message }}
          CHAT_HISTORY_RAW: ${{ steps.read.outputs.chathistory }}
          TRAVELER_PROFILE_RAW: ${{ steps.read.outputs.traveler_profile }}
          TRAVEL_INPUTS_RAW: ${{ steps.read.outputs.travel_inputs }}
          USER_ID_INPUT: ${{ steps.read.outputs.user_id_input }}
          GS_SCRIPT_URL: ${{ secrets.GS_SCRIPT_URL }}
          GS_SCRIPT_KEY: ${{ secrets.GS_SCRIPT_KEY }}
        run: |
          set -euo pipefail

          ANALYSIS=""
          RESPONSE=""
          ERROR_MSG=""

          # Build request body:
          IS_JSON=$(printf '%s' "$PROMPT_RAW" | jq -e . >/dev/null 2>&1 && echo "true" || echo "false")
          if [ "$IS_JSON" = "true" ]; then
            TYPE=$(printf '%s' "$PROMPT_RAW" | jq -r 'type' 2>/dev/null || echo "string")
            if [ "$TYPE" = "array" ]; then
              REQUEST_BODY=$(jq -n --argjson msgs "$PROMPT_RAW" '{
                model: "accounts/fireworks/models/kimi-k2-thinking",
                max_tokens: 16000,
                temperature: 0.5,
                messages: $msgs,
                stream: true
              }')
            else
              HAS_MESSAGES=$(printf '%s' "$PROMPT_RAW" | jq 'has("messages")' 2>/dev/null || echo "false")
              if [ "$HAS_MESSAGES" = "true" ]; then
                REQUEST_BODY=$(jq -n --argjson obj "$PROMPT_RAW" '{
                  model: "accounts/fireworks/models/kimi-k2-thinking",
                  max_tokens: 16000,
                  temperature: 0.5,
                  messages: $obj.messages,
                  stream: true
                }')
              else
                REQUEST_BODY=$(jq -n --argjson obj "$PROMPT_RAW" '{
                  model: "accounts/fireworks/models/kimi-k2-thinking",
                  max_tokens: 16000,
                  temperature: 0.5,
                  messages: [{role:"system", content: ($obj|tostring)}],
                  stream: true
                }')
              fi
            fi
          else
            REQUEST_BODY=$(jq -n --arg prompt "$PROMPT_RAW" '{
              model: "accounts/fireworks/models/kimi-k2-thinking",
              max_tokens: 16000,
              temperature: 0.5,
              messages: [{role: "user", content: $prompt}],
              stream: true
            }')
          fi

          echo "Starting streaming request to Fireworks (request_id=$REQUEST_ID)..."
          echo "Request body size: $(printf '%s' "$REQUEST_BODY" | wc -c) bytes"

          # Stream processing: read line by line, handle data: [DONE], accumulate analysis and response
          while IFS= read -r line; do
            if [[ $line == data:* ]]; then
              JSON_DATA="${line#data:}"
              JSON_TRIM=$(printf '%s' "$JSON_DATA" | tr -d '\r\n')
              if [[ "$JSON_TRIM" == "[DONE]" ]]; then
                echo "Stream finished ([DONE])"
                break
              fi
              if [[ -n "$JSON_TRIM" ]]; then
                PART_ANALYSIS=$(printf '%s' "$JSON_TRIM" | jq -r '.choices[0].delta.reasoning_content // empty' 2>/dev/null || true)
                if [[ -n "$PART_ANALYSIS" ]]; then
                  ANALYSIS+="$PART_ANALYSIS"
                fi

                PART_RESPONSE=$(printf '%s' "$JSON_TRIM" | jq -r '.choices[0].delta.content // empty' 2>/dev/null || true)
                if [[ -n "$PART_RESPONSE" ]]; then
                  RESPONSE+="$PART_RESPONSE"
                fi

                PART_ERROR=$(printf '%s' "$JSON_TRIM" | jq -r '.error.message // empty' 2>/dev/null || true)
                if [[ -n "$PART_ERROR" ]]; then
                  ERROR_MSG+="$PART_ERROR"
                fi
              fi
            fi
          done < <(
            curl -s -N https://api.fireworks.ai/inference/v1/chat/completions \
              -H "Authorization: Bearer $FIREWORKS_API_KEY" \
              -H "Content-Type: application/json" \
              -d "$REQUEST_BODY"
          )

          echo "Streaming complete. Analysis length: ${#ANALYSIS}, Response length: ${#RESPONSE}"
          echo "Any errors captured: ${ERROR_MSG:-<none>}"

          # Use explicit inputs if provided; fallback to PROMPT_RAW for InputMessage
          INPUT_MSG="${INPUT_MESSAGE_RAW:-$PROMPT_RAW}"
          CHAT_HISTORY="${CHAT_HISTORY_RAW:-[]}"
          TRAVELER_PROFILE="${TRAVELER_PROFILE_RAW:-{}}"
          TRAVEL_INPUTS="${TRAVEL_INPUTS_RAW:-{}}"
          # Use a non-reserved shell variable name for the user id
          USER_ID_VAR="${USER_ID_INPUT:-}"

          NOW=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          POLL_AT=$(date -u -d "+30 seconds" +"%Y-%m-%dT%H:%M:%SZ")
          mkdir -p status

          # Build status JSON including all inputs for traceability (initial raw response stored)
          if [[ "${NEEDS_POLLING}" == "true" ]]; then
            STATUS_JSON=$(jq -n \
              --arg rid "$REQUEST_ID" \
              --arg status "completed" \
              --arg createdAt "$NOW" \
              --arg updatedAt "$NOW" \
              --arg poll_at "$POLL_AT" \
              --argjson timeout_seconds 180 \
              --argjson poll_interval 20 \
              --arg response_text "$RESPONSE" \
              --arg analysis_text "$ANALYSIS" \
              --arg inputmsg "$INPUT_MSG" \
              --arg chath "$CHAT_HISTORY" \
              --arg traveler "$TRAVELER_PROFILE" \
              --arg travel_inputs "$TRAVEL_INPUTS" \
              --arg user_id "$USER_ID_VAR" \
              --arg error_msg "$ERROR_MSG" \
              '{
                request_id: $rid,
                status: $status,
                createdAt: $createdAt,
                updatedAt: $updatedAt,
                poll_at: $poll_at,
                timeout_seconds: $timeout_seconds,
                poll_interval: $poll_interval,
                response: { text: $response_text },
                analysis: $analysis_text,
                InputMessage: $inputmsg,
                ChatHistory: ($chath | fromjson? // $chath),
                TravelerProfile: ($traveler | fromjson? // $traveler),
                TravelInputs: ($travel_inputs | fromjson? // $travel_inputs),
                user_id: $user_id,
                error: $error_msg
              }'
            )
          else
            STATUS_JSON=$(jq -n \
              --arg rid "$REQUEST_ID" \
              --arg status "completed" \
              --arg createdAt "$NOW" \
              --arg updatedAt "$NOW" \
              --arg response_text "$RESPONSE" \
              --arg analysis_text "$ANALYSIS" \
              --arg inputmsg "$INPUT_MSG" \
              --arg chath "$CHAT_HISTORY" \
              --arg traveler "$TRAVELER_PROFILE" \
              --arg travel_inputs "$TRAVEL_INPUTS" \
              --arg user_id "$USER_ID_VAR" \
              --arg error_msg "$ERROR_MSG" \
              '{
                request_id: $rid,
                status: $status,
                createdAt: $createdAt,
                updatedAt: $updatedAt,
                response: { text: $response_text },
                analysis: $analysis_text,
                InputMessage: $inputmsg,
                ChatHistory: ($chath | fromjson? // $chath),
                TravelerProfile: ($traveler | fromjson? // $traveler),
                TravelInputs: ($travel_inputs | fromjson? // $travel_inputs),
                user_id: $user_id,
                error: $error_msg
              }'
            )
          fi

          echo "$STATUS_JSON" > status/$REQUEST_ID.json
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add status/$REQUEST_ID.json
          git commit -m "Write status for $REQUEST_ID (streaming result)" || echo "no changes"
          git push || echo "git push failed (continuing)"

          # --- Início do bloco: limpeza, extração e envio ao webhook ---
          raw_response="${RESPONSE:-}"

          # 1) Remover code fences e prefixos comuns (```json, ```)
          cleaned=$(printf '%s' "$raw_response" | sed -E 's/^```[[:alpha:]]*//; s/```$//; s/^\s+//; s/\s+$//')

          # 2) Remover prefixos como "json{" -> "{"
          cleaned=$(printf '%s' "$cleaned" | sed -E 's/^json\s*({)/\1/')

          # 3) Se o texto for JSON, extrair .message quando existir
          message_extracted=""
          if printf '%s' "$cleaned" | jq -e . >/dev/null 2>&1; then
            message_extracted=$(printf '%s' "$cleaned" | jq -r '.message // (. | tostring)' 2>/dev/null || true)
          else
            message_extracted="$cleaned"
          fi

          # 4) Fallback para a resposta bruta se ainda estiver vazio
          if [ -z "${message_extracted:-}" ]; then
            message_extracted="$raw_response"
          fi

          # 5) Preparar versões Markdown e HTML simples
          response_text_markdown="$message_extracted"
          escape_html() {
            printf '%s' "$1" | sed -e 's/&/\&amp;/g' -e 's/</\&lt;/g' -e 's/>/\&gt;/g'
          }
          escaped=$(escape_html "$response_text_markdown")
          response_text_html=$(printf '%s' "$escaped" | sed ':a;N;$!ba;s/\n/<br>/g')

          # 6) Garantir user_id final (prioriza USER_ID_VAR, depois USER_ID_INPUT)
          user_id_final="${USER_ID_VAR:-${USER_ID_INPUT:-}}"

          # 7) Montar payload final com campos limpos e formatados
          OUT_PAYLOAD=$(jq -n \
            --arg rid "$REQUEST_ID" \
            --arg response "$message_extracted" \
            --arg md "$response_text_markdown" \
            --arg html "$response_text_html" \
            --arg input "$INPUT_MSG" \
            --arg user_id "$user_id_final" \
            '{
              request_id: $rid,
              response_text_clean: $response,
              response_text_markdown: $md,
              response_text_html: $html,
              InputMessage: $input,
              user_id: $user_id
            }'
          )

          # 8) Enviar ao webhook com retries exponenciais
          if [ -z "${WEBHOOK_URL:-}" ]; then
            echo "No WEBHOOK_URL provided; skipping webhook post."
          else
            MAX_RETRIES=3
            ATTEMPT=1
            SUCCESS=0
            while [ $ATTEMPT -le $MAX_RETRIES ]; do
              echo "Posting cleaned payload to webhook (attempt $ATTEMPT)..."
              HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" -X POST "$WEBHOOK_URL" \
                -H "Content-Type: application/json" \
                -d "$OUT_PAYLOAD" || echo "000")
              if [ "$HTTP_STATUS" = "200" ] || [ "$HTTP_STATUS" = "201" ] || [ "$HTTP_STATUS" = "204" ]; then
                echo "Webhook post succeeded (HTTP $HTTP_STATUS)."
                SUCCESS=1
                break
              else
                echo "Webhook post failed (HTTP $HTTP_STATUS). Retrying..."
                sleep $((2 ** ATTEMPT))
                ATTEMPT=$((ATTEMPT + 1))
              fi
            done

            if [ $SUCCESS -ne 1 ]; then
              echo "All webhook attempts failed; last status $HTTP_STATUS. Continuing workflow."
            fi
          fi
          # --- Fim do bloco ---

          # Optional: Post to Google Sheets (Apps Script) if configured
          if [ -n "${GS_SCRIPT_URL:-}" ]; then
            GS_PAYLOAD=$(jq -n \
              --arg rid "$REQUEST_ID" \
              --arg ts "$NOW" \
              --arg text "$message_extracted" \
              --arg input "$INPUT_MSG" \
              --arg user_id "$user_id_final" \
              '{request_id:$rid, timestamp:$ts, response_text:$text, InputMessage:$input, user_id:$user_id}')
            if [ -n "${GS_SCRIPT_KEY:-}" ]; then
              curl -s -X POST "$GS_SCRIPT_URL" -H "Content-Type: application/json" -H "X-Script-Key: $GS_SCRIPT_KEY" -d "$GS_PAYLOAD" || echo "GS post failed"
            else
              curl -s -X POST "$GS_SCRIPT_URL" -H "Content-Type: application/json" -d "$GS_PAYLOAD" || echo "GS post failed"
            fi
          else
            echo "GS_SCRIPT_URL not configured; skipping Google Sheets post."
          fi

          echo "Done processing request_id=$REQUEST_ID"

      - name: Post job cleanup
        if: always()
        run: |
          echo "Post job cleanup."
