name: Fireworks proxy sync (streaming, save status, notify Make and Google Sheets)

on:
  workflow_dispatch:
    inputs:
      prompt:
        description: 'Prompt para o Kimi K2'
        required: true
        type: string
      request_id:
        description: 'ID único da requisição'
        required: true
        type: string
      webhook_url:
        description: 'Optional Make webhook URL to notify'
        required: false
        type: string
      needs_polling:
        description: 'true or false'
        required: false
        default: 'true'
  repository_dispatch:
    types: [fireworks-request-sync]

jobs:
  process-api:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Prepare env from event
        id: prep
        run: |
          # Prefer workflow_dispatch inputs, fallback to repository_dispatch client_payload
          PROMPT="${{ github.event.inputs.prompt || github.event.client_payload.prompt }}"
          REQUEST_ID="${{ github.event.inputs.request_id || github.event.client_payload.request_id }}"
          WEBHOOK_URL="${{ github.event.inputs.webhook_url || github.event.client_payload.webhook_url || '' }}"
          NEEDS_POLLING="${{ github.event.inputs.needs_polling || github.event.client_payload.needs_polling || 'true' }}"
          # Export for later steps
          echo "PROMPT<<EOF" >> $GITHUB_OUTPUT
          echo "$PROMPT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "REQUEST_ID=$REQUEST_ID" >> $GITHUB_OUTPUT
          echo "WEBHOOK_URL=$WEBHOOK_URL" >> $GITHUB_OUTPUT
          echo "NEEDS_POLLING=$NEEDS_POLLING" >> $GITHUB_OUTPUT

      - name: Process Fireworks AI Streaming and persist results
        env:
          FIREWORKS_API_KEY: ${{ secrets.FIREWORKS_API_KEY }}
          PROMPT: ${{ steps.prep.outputs.PROMPT }}
          REQUEST_ID: ${{ steps.prep.outputs.REQUEST_ID }}
          WEBHOOK_URL: ${{ steps.prep.outputs.WEBHOOK_URL }}
          NEEDS_POLLING: ${{ steps.prep.outputs.NEEDS_POLLING }}
          GS_SCRIPT_URL: ${{ secrets.GS_SCRIPT_URL }}
          GS_SCRIPT_KEY: ${{ secrets.GS_SCRIPT_KEY }}
        run: |
          set -euo pipefail

          ANALYSIS=""
          RESPONSE=""
          ERROR_MSG=""

          # Build request body safely with jq to preserve escaping
          REQUEST_BODY=$(jq -n --arg prompt "$PROMPT" '{
            model: "accounts/fireworks/models/kimi-k2-thinking",
            max_tokens: 16000,
            temperature: 0.5,
            messages: [{role: "user", content: $prompt}],
            stream: true
          }')

          echo "Starting streaming request to Fireworks (request_id=$REQUEST_ID)..."
          echo "Request body size: $(printf '%s' "$REQUEST_BODY" | wc -c) bytes"

          # Stream processing: read line by line, handle data: [DONE], accumulate analysis and response
          while IFS= read -r line; do
            # Only process lines that start with "data:"
            if [[ $line == data:* ]]; then
              # Remove prefix "data:" (may be "data: " or "data:")
              JSON_DATA="${line#data:}"
              # Trim CR/LF
              JSON_TRIM=$(printf '%s' "$JSON_DATA" | tr -d '\r\n')
              if [[ "$JSON_TRIM" == "[DONE]" ]]; then
                echo "Stream finished ([DONE])"
                break
              fi
              if [[ -n "$JSON_TRIM" ]]; then
                # Debug: print partial JSON (safe)
                echo "---- partial JSON ----"
                printf '%s\n' "$JSON_TRIM" | jq . || echo "partial not valid JSON for jq"

                # Extract reasoning content if present
                PART_ANALYSIS=$(printf '%s' "$JSON_TRIM" | jq -r '.choices[0].delta.reasoning_content // empty' 2>/dev/null || true)
                if [[ -n "$PART_ANALYSIS" ]]; then
                  ANALYSIS+="$PART_ANALYSIS"
                fi

                # Extract incremental content
                PART_RESPONSE=$(printf '%s' "$JSON_TRIM" | jq -r '.choices[0].delta.content // empty' 2>/dev/null || true)
                if [[ -n "$PART_RESPONSE" ]]; then
                  RESPONSE+="$PART_RESPONSE"
                fi

                # Extract error message if present
                PART_ERROR=$(printf '%s' "$JSON_TRIM" | jq -r '.error.message // empty' 2>/dev/null || true)
                if [[ -n "$PART_ERROR" ]]; then
                  ERROR_MSG+="$PART_ERROR"
                fi
              fi
            fi
          done < <(
            curl -s -N https://api.fireworks.ai/inference/v1/chat/completions \
              -H "Authorization: Bearer $FIREWORKS_API_KEY" \
              -H "Content-Type: application/json" \
              -d "$REQUEST_BODY"
          )

          echo "Streaming complete. Analysis length: ${#ANALYSIS}, Response length: ${#RESPONSE}"
          echo "Any errors captured: ${ERROR_MSG:-<none>}"

          # Prepare InputMessage: try to extract from original prompt or payload
          # If Make provided input_message in client_payload, it would be available in github.event.client_payload,
          # but we don't have direct access here; best-effort: use PROMPT as InputMessage
          INPUT_MSG="$PROMPT"

          NOW=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          POLL_AT=$(date -u -d "+30 seconds" +"%Y-%m-%dT%H:%M:%SZ")
          mkdir -p status

          # Build status JSON and write to repo (include poll_at if needs_polling)
          if [[ "${NEEDS_POLLING}" == "true" ]]; then
            STATUS_JSON=$(jq -n \
              --arg rid "$REQUEST_ID" \
              --arg status "completed" \
              --arg createdAt "$NOW" \
              --arg updatedAt "$NOW" \
              --arg poll_at "$POLL_AT" \
              --argjson timeout_seconds 180 \
              --argjson poll_interval 20 \
              --arg response_text "$RESPONSE" \
              --arg analysis_text "$ANALYSIS" \
              --arg inputmsg "$INPUT_MSG" \
              --arg error_msg "$ERROR_MSG" \
              '{
                request_id: $rid,
                status: $status,
                createdAt: $createdAt,
                updatedAt: $updatedAt,
                poll_at: $poll_at,
                timeout_seconds: $timeout_seconds,
                poll_interval: $poll_interval,
                response: { text: $response_text },
                analysis: $analysis_text,
                InputMessage: $inputmsg,
                error: $error_msg
              }'
            )
          else
            STATUS_JSON=$(jq -n \
              --arg rid "$REQUEST_ID" \
              --arg status "completed" \
              --arg createdAt "$NOW" \
              --arg updatedAt "$NOW" \
              --arg response_text "$RESPONSE" \
              --arg analysis_text "$ANALYSIS" \
              --arg inputmsg "$INPUT_MSG" \
              --arg error_msg "$ERROR_MSG" \
              '{
                request_id: $rid,
                status: $status,
                createdAt: $createdAt,
                updatedAt: $updatedAt,
                response: { text: $response_text },
                analysis: $analysis_text,
                InputMessage: $inputmsg,
                error: $error_msg
              }'
            )
          fi

          echo "$STATUS_JSON" > status/$REQUEST_ID.json
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add status/$REQUEST_ID.json
          git commit -m "Write status for $REQUEST_ID (streaming result)" || echo "no changes"
          git push

          # Post to Google Sheets (Apps Script) if configured
          if [ -n "${GS_SCRIPT_URL:-}" ]; then
            GS_PAYLOAD=$(jq -n --arg rid "$REQUEST_ID" --arg ts "$NOW" --arg text "$RESPONSE" --arg input "$INPUT_MSG" '{request_id:$rid, timestamp:$ts, response_text:$text, InputMessage:$input}')
            if [ -n "${GS_SCRIPT_KEY:-}" ]; then
              curl -s -X POST "$GS_SCRIPT_URL" -H "Content-Type: application/json" -H "X-Script-Key: $GS_SCRIPT_KEY" -d "$GS_PAYLOAD" || echo "GS post failed"
            else
              curl -s -X POST "$GS_SCRIPT_URL" -H "Content-Type: application/json" -d "$GS_PAYLOAD" || echo "GS post failed"
            fi
          else
            echo "GS_SCRIPT_URL not configured; skipping Google Sheets post."
          fi

          # Notify Make via webhook_url (if provided) with retry (3 attempts), no secret header
          if [ -n "${WEBHOOK_URL:-}" ]; then
            OUT_PAYLOAD=$(jq -n --arg rid "$REQUEST_ID" --arg response "$RESPONSE" --arg input "$INPUT_MSG" '{request_id:$rid, response_text:$response, InputMessage:$input}')
            MAX_RETRIES=3
            SLEEP_BASE=2
            ATTEMPT=1
            SUCCESS=0
            while [ $ATTEMPT -le $MAX_RETRIES ]; do
              echo "Posting to Make webhook (attempt $ATTEMPT)..."
              HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" -X POST "$WEBHOOK_URL" -H "Content-Type: application/json" -d "$OUT_PAYLOAD" || echo "000")
              if [ "$HTTP_STATUS" = "200" ] || [ "$HTTP_STATUS" = "201" ] || [ "$HTTP_STATUS" = "204" ]; then
                echo "Webhook post succeeded (HTTP $HTTP_STATUS)."
                SUCCESS=1
                break
              else
                echo "Webhook post failed (HTTP $HTTP_STATUS)."
                SLEEP_TIME=$((SLEEP_BASE ** ATTEMPT))
                echo "Sleeping $SLEEP_TIME seconds before retry..."
                sleep $SLEEP_TIME
                ATTEMPT=$((ATTEMPT + 1))
              fi
            done
            if [ $SUCCESS -ne 1 ]; then
              echo "All webhook attempts failed; continuing. Make should handle retries or manual reconciliation."
            fi
          else
            echo "No WEBHOOK_URL provided; skipping Make notification."
          fi

          echo "Done processing request_id=$REQUEST_ID"
