name: Fireworks AI Proxy (stream debug)

on:
  repository_dispatch:
    types: [fireworks-request-sync]
  workflow_dispatch:
    inputs:
      prompt:
        description: 'Prompt para o Kimi K2'
        required: true
        type: string
      request_id:
        description: 'ID único da requisição'
        required: true
        type: string
      webhook_url:
        description: 'URL do webhook Make.com'
        required: true
        type: string

jobs:
  process-api:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Process Fireworks AI Streaming (line-by-line debug)
        env:
          FIREWORKS_API_KEY: ${{ secrets.FIREWORKS_API_KEY }}
          PROMPT: ${{ github.event.inputs.prompt || github.event.client_payload.prompt }}
          REQUEST_ID: ${{ github.event.inputs.request_id || github.event.client_payload.request_id }}
          WEBHOOK_URL: ${{ github.event.inputs.webhook_url || github.event.client_payload.webhook_url }}
        run: |
          set -euo pipefail

          ANALYSIS=""
          RESPONSE=""
          ERROR_MSG=""

          # Temp files for raw stream and curl stderr
          RAW_STREAM_FILE=$(mktemp)
          CURL_ERR_FILE=$(mktemp)

          # Build request body safely with jq -n (escapes prompt)
          REQUEST_BODY=$(jq -n --arg prompt "$PROMPT" '{
            model: "accounts/fireworks/models/kimi-k2-thinking",
            max_tokens: 16000,
            temperature: 0.5,
            messages: [{role: "user", content: $prompt}],
            stream: true
          }')

          echo "=== REQUEST_BODY (preview) ==="
          printf '%s\n' "$REQUEST_BODY" | head -c 2000 || true
          echo "=============================="

          echo "STREAM: starting curl --no-buffer (this will block until stream ends or connection closes)"
          LINE_NO=0
          DELTA_COUNT=0
          REASONING_COUNT=0

          # Use a subshell to capture curl stderr separately and pipe stdout to the while loop
          (
            curl --no-buffer -s -N https://api.fireworks.ai/inference/v1/chat/completions \
              -H "Authorization: Bearer $FIREWORKS_API_KEY" \
              -H "Content-Type: application/json" \
              -H "Accept: text/event-stream, application/json" \
              -d "$REQUEST_BODY"
          ) 2> "$CURL_ERR_FILE" | while IFS= read -r line; do
            LINE_NO=$((LINE_NO+1))
            TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
            # Normalize line for logging
            LOG_LINE="$TIMESTAMP | line:$LINE_NO | raw: $line"

            # Save raw line to file for later inspection
            printf '%s\n' "$line" >> "$RAW_STREAM_FILE"

            # Print a short log for each line (keeps logs readable)
            echo "STREAM LINE $LINE_NO @ $TIMESTAMP"
            # Try to pretty-print JSON if possible, otherwise print raw
            if printf '%s' "$line" | jq . >/dev/null 2>&1; then
              printf '%s\n' "$line" | jq . || true
            else
              echo "$line"
            fi

            # Handle SSE "data:" prefix and ignore [DONE]
            if [[ $line == data:* ]]; then
              JSON_DATA=${line:5}
            else
              JSON_DATA="$line"
            fi

            # Skip empty or DONE markers
            if [[ -z "$JSON_DATA" ]] || [[ "$JSON_DATA" == "[DONE]" ]]; then
              echo "STREAM: skipped empty or [DONE] marker"
              continue
            fi

            # Try to extract reasoning fragment (delta.reasoning_content)
            PART_ANALYSIS=$(printf '%s' "$JSON_DATA" | jq -r '.choices? // [] | .[] | .delta? // {} | .reasoning_content? // empty' 2>/dev/null || true)
            if [[ -n "$PART_ANALYSIS" ]]; then
              REASONING_COUNT=$((REASONING_COUNT+1))
              # preserve separation between fragments
              if [[ -n "$ANALYSIS" ]]; then
                ANALYSIS+=$'\n'"$PART_ANALYSIS"
              else
                ANALYSIS="$PART_ANALYSIS"
              fi
              echo "STREAM: captured reasoning fragment (len=${#PART_ANALYSIS})"
            fi

            # Try to extract content fragment (delta.content)
            PART_RESPONSE=$(printf '%s' "$JSON_DATA" | jq -r '.choices? // [] | .[] | .delta? // {} | .content? // empty' 2>/dev/null || true)
            if [[ -n "$PART_RESPONSE" ]]; then
              DELTA_COUNT=$((DELTA_COUNT+1))
              if [[ -n "$RESPONSE" ]]; then
                RESPONSE+=$'\n'"$PART_RESPONSE"
              else
                RESPONSE="$PART_RESPONSE"
              fi
              echo "STREAM: captured content fragment (len=${#PART_RESPONSE})"
            fi

            # Also try to capture full message objects (non-delta)
            FULL_MSG=$(printf '%s' "$JSON_DATA" | jq -r '.choices? // [] | .[] | .message? // empty' 2>/dev/null || true)
            if [[ -n "$FULL_MSG" && "$FULL_MSG" != "null" ]]; then
              MSG_CONTENT=$(printf '%s' "$FULL_MSG" | jq -r '.content // empty' 2>/dev/null || true)
              if [[ -n "$MSG_CONTENT" ]]; then
                if [[ -n "$RESPONSE" ]]; then
                  RESPONSE+=$'\n'"$MSG_CONTENT"
                else
                  RESPONSE="$MSG_CONTENT"
                fi
                echo "STREAM: captured full message content (len=${#MSG_CONTENT})"
              fi
            fi

            # Capture error if present
            PART_ERROR=$(printf '%s' "$JSON_DATA" | jq -r '.error.message // empty' 2>/dev/null || true)
            if [[ -n "$PART_ERROR" ]]; then
              if [[ -n "$ERROR_MSG" ]]; then
                ERROR_MSG+=$'\n'"$PART_ERROR"
              else
                ERROR_MSG="$PART_ERROR"
              fi
              echo "STREAM: captured error fragment: $PART_ERROR"
            fi
          done

          # After stream ends, show curl stderr if any
          if [ -s "$CURL_ERR_FILE" ]; then
            echo "CURL STDERR (preview):"
            head -c 2000 "$CURL_ERR_FILE" || true
          fi

          echo "STREAM finished. Lines received: $LINE_NO, content fragments: $DELTA_COUNT, reasoning fragments: $REASONING_COUNT"
          echo "Raw stream file path: $RAW_STREAM_FILE (first 2000 chars below)"
          head -c 2000 "$RAW_STREAM_FILE" || true
          echo

          # Trim leading/trailing whitespace/newlines from RESPONSE and ANALYSIS
          RESPONSE="$(printf '%s' "$RESPONSE" | sed -e 's/^[[:space:]\n\r]*//' -e 's/[[:space:]\n\r]*$//')"
          ANALYSIS="$(printf '%s' "$ANALYSIS" | sed -e 's/^[[:space:]\n\r]*//' -e 's/[[:space:]\n\r]*$//')"
          ERROR_MSG="$(printf '%s' "$ERROR_MSG" | sed -e 's/^[[:space:]\n\r]*//' -e 's/[[:space:]\n\r]*$//')"

          echo "Análise capturada: ${#ANALYSIS} caracteres"
          echo "Resposta capturada: ${#RESPONSE} caracteres"
          echo "Erro capturado: ${ERROR_MSG:-<none>}"

          # If RESPONSE empty, mark explicitly so webhook consumer sees it
          if [ -z "${RESPONSE// }" ]; then
            RESPONSE="__NO_RESPONSE_FROM_MODEL__"
            echo "WARN: response empty after parsing -> using fallback marker"
          fi

          # Build minimal payload for webhook (request_id, status, response.text, user_id optional, analysis)
          PAYLOAD=$(jq -n \
            --arg request_id "$REQUEST_ID" \
            --arg status "completed" \
            --arg response "$RESPONSE" \
            --arg analysis "$ANALYSIS" \
            --arg error "$ERROR_MSG" \
            --arg user_id "" \
            '{request_id:$request_id, status:$status, response:{text:$response}, reasoning:$analysis, error:$error, user_id:$user_id}')

          echo "Payload a enviar para webhook (preview):"
          echo "$PAYLOAD" | jq .

          # Send to webhook (Make.com)
          if [ -n "${WEBHOOK_URL:-}" ]; then
            HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" -X POST "$WEBHOOK_URL" \
              -H "Content-Type: application/json" \
              --data-binary "$PAYLOAD" || echo "000")
            echo "Webhook notify -> HTTP $HTTP_STATUS"
          else
            echo "No WEBHOOK_URL provided; skipping notify."
          fi

          # Keep raw stream file as artifact in logs for debugging (printed above)
          # Clean up temp files except RAW_STREAM_FILE for inspection in logs (runner will remove workspace after)
          rm -f "$CURL_ERR_FILE" || true

          echo "Done processing request_id=$REQUEST_ID"
